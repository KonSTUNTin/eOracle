/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.5.1
 * Wed, 04 Sep 2024 07:56:27 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables used in the init tab
const _initGlob = {
    percentage: 0,
    output: {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        },
    },
};


// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];
_pGlob.htmlElements = new Set();

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

const createPzLib = ({ v3d=null, appInstance=null }) => {
    function areListenersSame(target0, type0, listener0, optionsOrUseCapture0,
            target1, type1, listener1, optionsOrUseCapture1) {
        const capture0 = Boolean(optionsOrUseCapture0 instanceof Object
                ? optionsOrUseCapture0.capture : optionsOrUseCapture0);
        const capture1 = Boolean(optionsOrUseCapture1 instanceof Object
                ? optionsOrUseCapture1.capture : optionsOrUseCapture1);
        return target0 === target1 && type0 === type1 && listener0 === listener1
                && capture0 === capture1;
    }
        
    function bindListener(target, type, listener, optionsOrUseCapture) {
        const alreadyExists = _pGlob.eventListeners.some(elem => {
            return areListenersSame(elem.target, elem.type, elem.listener,
                    elem.optionsOrUseCapture, target, type, listener,
                    optionsOrUseCapture);
        });
    
        if (!alreadyExists) {
            target.addEventListener(type, listener, optionsOrUseCapture);
            _pGlob.eventListeners.push({ target, type, listener,
                    optionsOrUseCapture });
        }
    }
        
    function getSceneAnimFrameRate(scene) {
        if (scene && 'animFrameRate' in scene.userData) {
            return scene.userData.animFrameRate;
        }
        return 24;
    }
        
    function getSceneByAction(action) {
        const root = action.getRoot();
        let scene = root.type === 'Scene' ? root : null;
        root.traverseAncestors(ancObj => {
            if (ancObj.type === 'Scene') {
                scene = ancObj;
            }
        });
        return scene;
    }
        
    function getObjectName(obj) {
        // auto-generated from a multi-material object, use parent name instead
        if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
            return obj.parent.name;
        } else {
            return obj.name;
        }
    }
        
    function initObjectPicking(callback, eventType, mouseDownUseTouchStart=false,
            allowedMouseButtons=null) {
    
        const elem = appInstance.renderer.domElement;
        bindListener(elem, eventType, pickListener);
    
        if (eventType === 'mousedown') {
    
            const touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
            bindListener(elem, touchEventName, pickListener);
    
        } else if (eventType === 'dblclick') {
    
            let prevTapTime = 0;
    
            function doubleTapCallback(event) {
                const now = new Date().getTime();
                const timesince = now - prevTapTime;
    
                if (timesince < 600 && timesince > 0) {
                    pickListener(event);
                    prevTapTime = 0;
                    return;
                }
    
                prevTapTime = new Date().getTime();
            }
    
            const touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
            bindListener(elem, touchEventName, doubleTapCallback);
        }
    
        const raycaster = new v3d.Raycaster();
    
        function pickListener(event) {
    
            // to handle unload in loadScene puzzle
            if (!appInstance.getCamera()) {
                return;
            }
    
            event.preventDefault();
    
            let xNorm = 0;
            let yNorm = 0;
            if (event instanceof MouseEvent) {
                if (allowedMouseButtons !== null && allowedMouseButtons.indexOf(event.button) === -1) {
                    return;
                }
                xNorm = event.offsetX / elem.clientWidth;
                yNorm = event.offsetY / elem.clientHeight;
            } else if (event instanceof TouchEvent) {
                const rect = elem.getBoundingClientRect();
                xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
                yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
            }
    
            _pGlob.screenCoords.x = xNorm * 2 - 1;
            _pGlob.screenCoords.y = -yNorm * 2 + 1;
            raycaster.setFromCamera(_pGlob.screenCoords, appInstance.getCamera(true));
    
            const objList = [];
            appInstance.scene.traverse(obj => objList.push(obj));
    
            const intersects = raycaster.intersectObjects(objList, false);
            callback(intersects, event);
        }
    }
        
    function isObjectWorthProcessing(obj) {
        return obj.type !== 'AmbientLight' && obj.name !== '' &&
                !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
                !obj.isAuxClippingMesh;
    }
        
    function getObjectByName(objName) {
        let objFound = null;
    
        const pGlobAvailable = _pGlob !== undefined;
        if (pGlobAvailable && objName in _pGlob.objCache) {
            objFound = _pGlob.objCache[objName] || null;
        }
    
        if (objFound && objFound.name === objName) {
            return objFound;
        }
    
        if (appInstance.scene) {
            appInstance.scene.traverse(obj => {
                if (!objFound && isObjectWorthProcessing(obj) && (obj.name === objName)) {
                    objFound = obj;
                    if (pGlobAvailable) {
                        _pGlob.objCache[objName] = objFound;
                    }
                }
            });
        }
        return objFound;
    }
        
    function isObjectAmongObjects(objNameToCheck, objNames) {
        if (!objNameToCheck) {
            return false;
        }
    
        for (let i = 0; i < objNames.length; i++) {
            if (objNameToCheck === objNames[i]) {
                return true;
            } else {
                // also check children which are auto-generated for multi-material objects
                const obj = getObjectByName(objNames[i]);
                if (obj && obj.type === 'Group') {
                    for (let j = 0; j < obj.children.length; j++) {
                        if (objNameToCheck === obj.children[j].name) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
        
    function getObjectNamesByGroupName(groupName) {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                const objGroupNames = obj.groupNames;
                if (!objGroupNames) {
                    return;
                }
    
                for (let i = 0; i < objGroupNames.length; i++) {
                    const objGroupName = objGroupNames[i];
                    if (objGroupName === groupName) {
                        objNameList.push(obj.name);
                    }
                }
            }
        });
        return objNameList;
    }
        
    function getAllObjectNames() {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                objNameList.push(obj.name);
            }
        });
        return objNameList;
    }
        
    function retrieveObjectNamesAccum(currObjNames, namesAccum) {
        if (typeof currObjNames === 'string') {
            namesAccum.push(currObjNames);
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'GROUP') {
            const newObjNames = getObjectNamesByGroupName(currObjNames[1]);
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'ALL_OBJECTS') {
            const newObjNames = getAllObjectNames();
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames)) {
            for (let i = 0; i < currObjNames.length; i++) {
                retrieveObjectNamesAccum(currObjNames[i], namesAccum);
            }
        }
    }
        
    function retrieveObjectNames(objNames) {
        const accum = [];
        retrieveObjectNamesAccum(objNames, accum);
        return accum.filter(name => name !== '');
    }
        
    function transformCoordsSpace(coords, spaceFrom, spaceTo, noSignChange=false) {
    
        if (spaceFrom === spaceTo) {
            return coords;
        }
    
        const y = coords.y;
        const z = coords.z;
    
        if (spaceFrom === 'Z_UP_RIGHT' && spaceTo === 'Y_UP_RIGHT') {
            coords.y = z;
            coords.z = noSignChange ? y : -y;
        } else if (spaceFrom === 'Y_UP_RIGHT' && spaceTo === 'Z_UP_RIGHT') {
            coords.y = noSignChange ? z : -z;
            coords.z = y;
        } else {
            console.error('transformCoordsSpace: Unsupported coordinate space');
        }
    
        return coords;
    }
        
    const transformEulerV3dToBlenderShortest = function() {
        const eulerTmp = new v3d.Euler();
        const eulerTmp2 = new v3d.Euler();
        const vec3Tmp = new v3d.Vector3();
    
        return function(euler, dest) {
            const eulerBlender = eulerTmp.copy(euler).reorder('YZX');
            const eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();
    
            const len = vec3Tmp.setFromEuler(eulerBlender).lengthSq();
            const lenAlt = vec3Tmp.setFromEuler(eulerBlenderAlt).lengthSq();
    
            dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
            return transformCoordsSpace(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
        }
    }();
        
    function getSceneCoordSystem() {
        const scene = appInstance.scene;
        if (scene && 'coordSystem' in scene.userData) {
            return scene.userData.coordSystem;
        }
    
        return 'Y_UP_RIGHT';
    }
        
    function RotationInterface() {
        /**
         * @ignore
         * For user manipulations use XYZ extrinsic rotations (which
         * are the same as ZYX intrinsic rotations)
         *     - Blender/Max/Maya use extrinsic rotations in the UI
         *     - XYZ is the default option, but could be set from
         *       some order hint if exported
         */
        this._userRotation = new v3d.Euler(0, 0, 0, 'ZYX');
        this._actualRotation = new v3d.Euler();
    }
    
    Object.assign(RotationInterface, {
        initObject: function(obj) {
            if (obj.userData.puzzles === undefined) {
                obj.userData.puzzles = {}
            }
            if (obj.userData.puzzles.rotationInterface === undefined) {
                obj.userData.puzzles.rotationInterface = new RotationInterface();
            }
    
            const rotUI = obj.userData.puzzles.rotationInterface;
            rotUI.updateFromObject(obj);
            return rotUI;
        },
    });
    
    Object.assign(RotationInterface.prototype, {
        updateFromObject: function(obj) {
            const SYNC_ROT_EPS = 1e-8;
    
            if (!this._actualRotation.equalsEps(obj.rotation, SYNC_ROT_EPS)) {
                this._actualRotation.copy(obj.rotation);
                this._updateUserRotFromActualRot();
            }
        },
    
        getActualRotation: function(euler) {
            return euler.copy(this._actualRotation);
        },
    
        setUserRotation: function(euler) {
            // don't copy the order, since it's fixed to ZYX for now
            this._userRotation.set(euler.x, euler.y, euler.z);
            this._updateActualRotFromUserRot();
        },
    
        getUserRotation: function(euler) {
            return euler.copy(this._userRotation);
        },
    
        _updateUserRotFromActualRot: function() {
            const order = this._userRotation.order;
            this._userRotation.copy(this._actualRotation).reorder(order);
        },
    
        _updateActualRotFromUserRot: function() {
            const order = this._actualRotation.order;
            this._actualRotation.copy(this._userRotation).reorder(order);
        },
    });
        
    function getMaterialEditableValues(matName) {
        const mat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
        if (!mat) {
            return [];
        }
    
        if (mat.isMeshNodeMaterial) {
            return Object.keys(mat.nodeValueMap);
        } else if (mat.isMeshStandardMaterial) {
            return ['metalness', 'roughness', 'bumpScale', 'emissiveIntensity',
                    'envMapIntensity'];
        } else {
            return [];
        }
    }

    return {
        bindListener, getSceneAnimFrameRate, getSceneByAction, getObjectName,
        initObjectPicking, isObjectAmongObjects, retrieveObjectNames, transformCoordsSpace,
        transformEulerV3dToBlenderShortest, getSceneCoordSystem, getObjectByName, RotationInterface,
        getMaterialEditableValues,
    };
};

var PL = {};
// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    const PzLib = createPzLib({ v3d });

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    // initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = false;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = true;
_initGlob.output.initOptions.useFullscreen = true;

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

const PzLib = createPzLib({ v3d, appInstance });

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["init"] = init;
this.procedures["set_scale"] = set_scale;
this.procedures["set_camera"] = set_camera;
this.procedures["visibility control"] = visibility_control;
this.procedures["set_x_offset"] = set_x_offset;
this.procedures["PLAY"] = PLAY;
this.procedures["scale_universe"] = scale_universe;
this.procedures["adaptive_scaling"] = adaptive_scaling;

var PROC = {
    "init": init,
    "set_scale": set_scale,
    "set_camera": set_camera,
    "visibility control": visibility_control,
    "set_x_offset": set_x_offset,
    "PLAY": PLAY,
    "scale_universe": scale_universe,
    "adaptive_scaling": adaptive_scaling,
};

var VARS = Object.defineProperties({}, {
    'transition_list': { get: function() { return transition_list; }, set: function(val) { transition_list = val; } },
    'x': { get: function() { return x; }, set: function(val) { x = val; } },
    'object': { get: function() { return object; }, set: function(val) { object = val; } },
    'start': { get: function() { return start; }, set: function(val) { start = val; } },
    'finish': { get: function() { return finish; }, set: function(val) { finish = val; } },
    't_x': { get: function() { return t_x; }, set: function(val) { t_x = val; } },
    't_y': { get: function() { return t_y; }, set: function(val) { t_y = val; } },
    'y': { get: function() { return y; }, set: function(val) { y = val; } },
    's_u': { get: function() { return s_u; }, set: function(val) { s_u = val; } },
    'mem': { get: function() { return mem; }, set: function(val) { mem = val; } },
    'transition': { get: function() { return transition; }, set: function(val) { transition = val; } },
    'time': { get: function() { return time; }, set: function(val) { time = val; } },
    'y_pos': { get: function() { return y_pos; }, set: function(val) { y_pos = val; } },
    'x_pos': { get: function() { return x_pos; }, set: function(val) { x_pos = val; } },
    'x_offset': { get: function() { return x_offset; }, set: function(val) { x_offset = val; } },
    'dir': { get: function() { return dir; }, set: function(val) { dir = val; } },
    'k': { get: function() { return k; }, set: function(val) { k = val; } },
    'k_2': { get: function() { return k_2; }, set: function(val) { k_2 = val; } },
    'step': { get: function() { return step; }, set: function(val) { step = val; } },
    'w': { get: function() { return w; }, set: function(val) { w = val; } },
    'h': { get: function() { return h; }, set: function(val) { h = val; } },
    'y_offset': { get: function() { return y_offset; }, set: function(val) { y_offset = val; } },
    'speed': { get: function() { return speed; }, set: function(val) { speed = val; } },
    'coin_shake_list': { get: function() { return coin_shake_list; }, set: function(val) { coin_shake_list = val; } },
    'list_text': { get: function() { return list_text; }, set: function(val) { list_text = val; } },
    'crystals on earth': { get: function() { return crystals_on_earth; }, set: function(val) { crystals_on_earth = val; } },
    'frames_text': { get: function() { return frames_text; }, set: function(val) { frames_text = val; } },
    'coins': { get: function() { return coins; }, set: function(val) { coins = val; } },
    'anti_adapt': { get: function() { return anti_adapt; }, set: function(val) { anti_adapt = val; } },
    'frames': { get: function() { return frames2; }, set: function(val) { frames2 = val; } },
});

var transition_list, x, object, start, finish, t_x, t_y, y, s_u, mem, transition, time, y_pos, x_pos, x_offset, dir, k, k_2, step, w, h, y_offset, speed, coin_shake_list, list_text, crystals_on_earth, frames_text, coins, anti_adapt, frames2;

_pGlob.animMixerCallbacks = [];

var initAnimationMixer = function() {

    function onMixerFinished(e) {
        var cb = _pGlob.animMixerCallbacks;
        var found = [];
        for (var i = 0; i < cb.length; i++) {
            if (cb[i][0] == e.action) {
                cb[i][0] = null; // desactivate
                found.push(cb[i][1]);
            }
        }
        for (var i = 0; i < found.length; i++) {
            found[i]();
        }
    }

    return function initAnimationMixer() {
        if (appInstance.mixer && !appInstance.mixer.hasEventListener('finished', onMixerFinished)) {
            PzLib.bindListener(appInstance.mixer, 'finished', onMixerFinished);
        }
    };

}();

// animation puzzles
function operateAnimation(operation, animations, from, to, loop, speed, callback, rev) {
    if (!animations)
        return;
    // input can be either single obj or array of objects
    if (typeof animations == "string")
        animations = [animations];

    function processAnimation(animName) {
        var action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
        if (!action)
            return;
        switch (operation) {
        case 'PLAY':
            if (!action.isRunning()) {
                action.reset();
                if (loop && (loop != "AUTO"))
                    action.loop = v3d[loop];
                var scene = PzLib.getSceneByAction(action);
                var frameRate = PzLib.getSceneAnimFrameRate(scene);

                action.repetitions = Infinity;

                var timeScale = Math.abs(parseFloat(speed));
                if (rev)
                    timeScale *= -1;

                action.timeScale = timeScale;
                action.timeStart = from !== null ? from/frameRate : 0;
                if (to !== null) {
                    action.getClip().duration = to/frameRate;
                } else {
                    action.getClip().resetDuration();
                }
                action.time = timeScale >= 0 ? action.timeStart : action.getClip().duration;

                action.paused = false;
                action.play();

                // push unique callbacks only
                var callbacks = _pGlob.animMixerCallbacks;
                var found = false;

                for (var j = 0; j < callbacks.length; j++)
                    if (callbacks[j][0] == action && callbacks[j][1] == callback)
                        found = true;

                if (!found)
                    _pGlob.animMixerCallbacks.push([action, callback]);
            }
            break;
        case 'STOP':
            action.stop();

            // remove callbacks
            var callbacks = _pGlob.animMixerCallbacks;
            for (var j = 0; j < callbacks.length; j++)
                if (callbacks[j][0] == action) {
                    callbacks.splice(j, 1);
                    j--
                }

            break;
        case 'PAUSE':
            action.paused = true;
            break;
        case 'RESUME':
            action.paused = false;
            break;
        case 'SET_FRAME':
            var scene = PzLib.getSceneByAction(action);
            var frameRate = PzLib.getSceneAnimFrameRate(scene);
            action.time = from ? from/frameRate : 0;
            action.play();
            action.paused = true;
            break;
        case 'SET_SPEED':
            var timeScale = parseFloat(speed);
            action.timeScale = rev ? -timeScale : timeScale;
            break;
        }
    }

    for (var i = 0; i < animations.length; i++) {
        var animName = animations[i];
        if (animName)
            processAnimation(animName);
    }

    initAnimationMixer();
}

// whenHovered puzzle
PzLib.initObjectPicking(function(intersects, event) {

    var prevHovered = _pGlob.hoveredObject;
    var currHovered = '';

    // the event might happen before hover registration
    _pGlob.objHoverInfo = _pGlob.objHoverInfo || [];

    // search for closest hovered object

    var lastIntersectIndex = Infinity;
    _pGlob.objHoverInfo.forEach(function(el) {
        var maxIntersects = el.xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = PzLib.getObjectName(obj);

            if (PzLib.isObjectAmongObjects(objName, PzLib.retrieveObjectNames(el.objSelector)) && i <= lastIntersectIndex) {
                currHovered = objName;
                lastIntersectIndex = i;
            }
        }
    });

    if (prevHovered == currHovered) return;

    // first - all "out" callbacks, then - all "over"
    _pGlob.objHoverInfo.forEach(function(el) {
        if (PzLib.isObjectAmongObjects(prevHovered, PzLib.retrieveObjectNames(el.objSelector))) {
            // ensure the correct value of the hoveredObject block
            _pGlob.hoveredObject = prevHovered;
            el.callbacks[1](event);
        }
    });

    _pGlob.objHoverInfo.forEach(function(el) {
        if (PzLib.isObjectAmongObjects(currHovered, PzLib.retrieveObjectNames(el.objSelector))) {
            // ensure the correct value of the hoveredObject block
            _pGlob.hoveredObject = currHovered;
            el.callbacks[0](event);
        }
    });

    _pGlob.hoveredObject = currHovered;
}, 'mousemove');

// whenHovered puzzle
function registerOnHover(objSelector, xRay, cbOver, cbOut) {

    _pGlob.objHoverInfo = _pGlob.objHoverInfo || [];

    _pGlob.objHoverInfo.push({
        objSelector: objSelector,
        callbacks: [cbOver, cbOut],
        xRay: xRay
    });
}

// Describe this function...
function init() {
  mem = [];
  time = 1;
  step = 0;
  transition = 0;
  coin_shake_list = 'logo.001,logo.101,logo.102,logo.103,logo.104,logo.105,logo.106,logo.107,logo.108,logo.109,logo.110,logo.111,logo.112,logo.113,logo.114,logo.115,logo.116,logo.117,logo.118,logo.119,logo.120,logo.121,logo.122,logo.123,logo.124,logo.125,logo.126,logo.127,logo.128,logo.129,logo.130,logo.131,logo.132,logo.133,logo.134,logo.135,logo.136,logo.137,logo.138,logo.139,logo.140,logo.141,logo.142,logo.143,logo.144,logo.145,logo.146,logo.147,logo.148,logo.149,logo.150,logo.151,logo.152,logo.153,logo.154,logo.155,logo.156,logo.157,logo.158,logo.159,logo.160,logo.161,logo.162,logo.163,logo.164,logo.165,logo.166,logo.167,logo.168,logo.169,logo.170,logo.171,logo.172,logo.173,logo.174,logo.175,logo.176,logo.177,logo.178,logo.179,logo.180,logo.181,logo.182,logo.183,logo.184,logo.185,logo.186,logo.187,logo.188,logo.189,logo.190,logo.191,logo.192,logo.193,logo.194,logo.195,logo.196,logo.197,'.split(',');
  list_text = 'logo.001_empty,logo.101_empty,logo.102_empty,logo.103_empty,logo.104_empty,logo.105_empty,logo.106_empty,logo.107_empty,logo.108_empty,logo.109_empty,logo.110_empty,logo.111_empty,logo.112_empty,logo.113_empty,logo.114_empty,logo.115_empty,logo.116_empty,logo.117_empty,logo.118_empty,logo.119_empty,logo.120_empty,logo.121_empty,logo.122_empty,logo.123_empty,logo.124_empty,logo.125_empty,logo.126_empty,logo.127_empty,logo.128_empty,logo.129_empty,logo.130_empty,logo.131_empty,logo.132_empty,logo.133_empty,logo.134_empty,logo.135_empty,logo.136_empty,logo.137_empty,logo.138_empty,logo.139_empty,logo.140_empty,logo.141_empty,logo.142_empty,logo.143_empty,logo.144_empty,logo.145_empty,logo.146_empty,logo.147_empty,logo.148_empty,logo.149_empty,logo.150_empty,logo.151_empty,logo.152_empty,logo.153_empty,logo.154_empty,logo.155_empty,logo.156_empty,logo.157_empty,logo.158_empty,logo.159_empty,logo.160_empty,logo.161_empty,logo.162_empty,logo.163_empty,logo.164_empty,logo.165_empty,logo.166_empty,logo.167_empty,logo.168_empty,logo.169_empty,logo.170_empty,logo.171_empty,logo.172_empty,logo.173_empty,logo.174_empty,logo.175_empty,logo.176_empty,logo.177_empty,logo.178_empty,logo.179_empty,logo.180_empty,logo.181_empty,logo.182_empty,logo.183_empty,logo.184_empty,logo.185_empty,logo.186_empty,logo.187_empty,logo.188_empty,logo.189_empty,logo.190_empty,logo.191_empty,logo.192_empty,logo.193_empty,logo.194_empty,logo.195_empty,logo.196_empty,logo.197_empty,';
  frames_text = '1,140,208,300,338,410,600,640';
  coins = list_text.split(',');
  frames2 = frames_text.split(',');
  crystals_on_earth = 'cryyyyyyy_,cryyyyyyy_.001,cryyyyyyy_.002,cryyyyyyy_.003,cryyyyyyy_.004,cryyyyyyy_.005,cryyyyyyy_.006,cryyyyyyy_.007,cryyyyyyy_.008,cryyyyyyy_.009,cryyyyyyy_.010,cryyyyyyy_.011,cryyyyyyy_.012,cryyyyyyy_.013,cryyyyyyy_.014,cryyyyyyy_.015,cryyyyyyy_.016,cryyyyyyy_.017,cryyyyyyy_.018,cryyyyyyy_.019,cryyyyyyy_.020,cryyyyyyy_.021,cryyyyyyy_.022,cryyyyyyy_.023,cryyyyyyy_.024,cryyyyyyy_.025,cryyyyyyy_.026,cryyyyyyy_.027,cryyyyyyy_.028,cryyyyyyy_.029,cryyyyyyy_.030,cryyyyyyy_.031,cryyyyyyy_.032,cryyyyyyy_.033,cryyyyyyy_.034,cryyyyyyy_.035,cryyyyyyy_.036,cryyyyyyy_.037'.split(',');

  operateAnimation('SET_FRAME', coins, 1, null, 'AUTO', 1,
          function() {}, false);


  Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('document.onkeydown = (e)=> {' + '\n' +
  '    e = e || window.event;' + '\n' +
  '    ' + '\n' +
  '    VARS.transition = 1;' + '\n' +
  '    if (e.keyCode == \'37\') {' + '\n' +
  '       ' + '\n' +
  '       VARS.dir = -1;' + '\n' +
  '       VARS.speed = 1;' + '\n' +
  '    }' + '\n' +
  '    else if (e.keyCode == \'39\') {' + '\n' +
  '        VARS.speed = .5;' + '\n' +
  '       VARS.dir = 1;' + '\n' +
  '    }' + '\n' +
  '' + '\n' +
  '}' + '\n' +
  '' + '\n' +
  '' + '\n' +
  'VARS.w = window.innerWidth' + '\n' +
  'VARS.h = window.innerHeight' + '\n' +
  'VARS.x_pos = 0;' + '\n' +
  'VARS.y_pos = 0;' + '\n' +
  '' + '\n' +
  'window.addEventListener(\'mousemove\', (e)=>{' + '\n' +
  '    let x = e.pageX;' + '\n' +
  '    let y = e.pageY;' + '\n' +
  '    VARS.x_pos = (x - VARS.w /2) / VARS.w * 7;' + '\n' +
  '    VARS.y_pos = (y - VARS.h /2) / VARS.h * 7;' + '\n' +
  '' + '\n' +
  '})' + '\n' +
  '' + '\n' +
  'window.addEventListener(\'resize\', ()=>{' + '\n' +
  '    VARS.w = window.innerWidth' + '\n' +
  '    VARS.h = window.innerHeight' + '\n' +
  '    puzzles.procedures.set_camera()' + '\n' +
  '});' + '\n' +
  'puzzles.procedures.set_camera()')))(appInstance, v3d, PL, VARS, PROC);

  k = 1;
  if (w > h * 2) {
    k = w / (h * 2);
  }
  set_x_offset((w / (h * 2)) * 0.25, 0.125);
  adaptive_scaling();
  registerOnHover(coin_shake_list, false, function() {

    operateAnimation('SET_FRAME', _pGlob.hoveredObject, 0, null, 'AUTO', 1,
            function() {}, false);


    operateAnimation('PLAY', _pGlob.hoveredObject, null, null, 'AUTO', 1,
            function() {}, false);

        }, function() {});
}

// setObjTransform puzzle
function setObjTransform(objSelector, isWorldSpace, mode, vector, offset){
    var x = vector[0];
      var y = vector[1];
      var z = vector[2];

    var objNames = PzLib.retrieveObjectNames(objSelector);

    function setObjProp(obj, prop, val) {
        if (!offset) {
            obj[mode][prop] = val;
        } else {
            if (mode != "scale")
                obj[mode][prop] += val;
            else
                obj[mode][prop] *= val;
        }
    }

    var inputsUsed = _pGlob.vec3Tmp.set(Number(x !== ''), Number(y !== ''),
            Number(z !== ''));
    var coords = _pGlob.vec3Tmp2.set(x || 0, y || 0, z || 0);

    if (mode === 'rotation') {
        // rotations are specified in degrees
        coords.multiplyScalar(v3d.MathUtils.DEG2RAD);
    }

    var coordSystem = PzLib.getSceneCoordSystem();

    PzLib.transformCoordsSpace(inputsUsed, coordSystem, 'Y_UP_RIGHT', true);
    PzLib.transformCoordsSpace(coords, coordSystem, 'Y_UP_RIGHT', mode === 'scale');

    for (var i = 0; i < objNames.length; i++) {

        var objName = objNames[i];
        if (!objName) continue;

        var obj = PzLib.getObjectByName(objName);
        if (!obj) continue;

        if (isWorldSpace && obj.parent) {
            obj.matrixWorld.decomposeE(obj.position, obj.rotation, obj.scale);

            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

            obj.matrixWorld.composeE(obj.position, obj.rotation, obj.scale);
            obj.matrix.multiplyMatrices(_pGlob.mat4Tmp.copy(obj.parent.matrixWorld).invert(), obj.matrixWorld);
            obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);

        } else if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
            // Blender/Max coordinates

            // need all the rotations for order conversions, especially if some
            // inputs are not specified
            var euler = PzLib.transformEulerV3dToBlenderShortest(obj.rotation,
                    _pGlob.eulerTmp);
            PzLib.transformCoordsSpace(euler, coordSystem, 'Y_UP_RIGHT');

            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            /**
             * convert from Blender/Max default XYZ extrinsic order to v3d XYZ
             * intrinsic with reversion (XYZ -> ZYX) and axes swizzling (ZYX -> YZX)
             */
            euler.order = "YZX";
            euler.reorder(obj.rotation.order);
            obj.rotation.copy(euler);

        } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
            // Maya coordinates

            // Use separate rotation interface to fix ambiguous rotations for Maya,
            // might as well do the same for Blender/Max.

            var rotUI = PzLib.RotationInterface.initObject(obj);
            var euler = rotUI.getUserRotation(_pGlob.eulerTmp);
            // TODO(ivan): this probably needs some reasonable wrapping
            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            rotUI.setUserRotation(euler);
            rotUI.getActualRotation(obj.rotation);
        } else {
            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

        }

        obj.updateMatrixWorld(true);
    }

}

// setMaterialValue puzzle
function setMaterialValue(matName, valName, value) {

    var values = PzLib.getMaterialEditableValues(matName);
    if (values.indexOf(valName) < 0)
        return;

    var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);

    for (var i = 0; i < mats.length; i++) {
        var mat = mats[i];

        if (mat.isMeshNodeMaterial) {
            var valIdx = mat.nodeValueMap[valName];
            mat.nodeValue[valIdx] = Number(value);
        } else
            mat[valName] = Number(value);

        if (appInstance.scene !== null) {
            if (mat === appInstance.scene.worldMaterial) {
                appInstance.updateEnvironment(mat);
            }
        }
    }
}

// everyFrame puzzle
function registerEveryFrame(callback) {
    if (typeof callback == 'function') {
        appInstance.renderCallbacks.push(callback);
        if (PL.editorRenderCallbacks)
            PL.editorRenderCallbacks.push([appInstance, callback]);
    }
}

// setCameraParam puzzle
function setCameraParam(type, camSelector, param) {

    const camNames = PzLib.retrieveObjectNames(camSelector);

    camNames.forEach(function(camName) {
        if (!camName)
            return;

        var cam = PzLib.getObjectByName(camName);
        if (!cam || !cam.isCamera) return;

        if (!(cam.isPerspectiveCamera || cam.isOrthographicCamera)) {
            console.error('setCameraParam: Incompatible camera type, have to be perspective or orthographic');
            return;
        }

        let isSetOrbitParam = false;
        let isSetFirstpersonParam = false;

        switch (type) {
            case 'ORBIT_MIN_DISTANCE_PERSP':
            case 'ORBIT_MAX_DISTANCE_PERSP':
            case 'ORBIT_MIN_ZOOM_ORTHO':
            case 'ORBIT_MAX_ZOOM_ORTHO':
            case 'ORBIT_MIN_VERTICAL_ANGLE':
            case 'ORBIT_MAX_VERTICAL_ANGLE':
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
            case 'ORBIT_ALLOW_TURNOVER':
                isSetOrbitParam = true;
                break;
            case 'ENABLE_COLLISIONS':
                isSetFirstpersonParam = true;
                break;
        }

        let isSetControlsParam = (['ROTATION_SPEED', 'MOVEMENT_SPEED', 'ALLOW_PANNING', 'ALLOW_ZOOM', 'KEYBOARD_CONTROLS'].includes(type) || isSetOrbitParam || isSetFirstpersonParam);

        if (isSetControlsParam) {
            if (!cam.controls) {
                console.error('setCameraParam: The "' + camName +'" camera has no controls');
                return;
            } else if ((isSetOrbitParam && cam.controlSettings.type != 'ORBIT') ||
                    (isSetFirstpersonParam && cam.controlSettings.type != 'FIRST_PERSON')) {
                console.error('setCameraParam: Incompatible camera controls: ' + cam.controlSettings.type);
                return;
            }
        }

        switch (type) {
            case 'FIELD_OF_VIEW':
                if (cam.isPerspectiveCamera) {
                    cam.fov = param;
                    cam.updateProjectionMatrix();
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORTHO_SCALE':
                if (cam.isOrthographicCamera) {
                    cam.zoom = param;
                    cam.updateProjectionMatrix();
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ROTATION_SPEED':
                cam.controlSettings.rotateSpeed = param;
                break;
            case 'MOVEMENT_SPEED':
                cam.controlSettings.moveSpeed = param;
                break;
            case 'ALLOW_PANNING':
                cam.controlSettings.enablePan = param;
                break;
            case 'ALLOW_ZOOM':
                cam.controlSettings.enableZoom = param;
                break;
            case 'KEYBOARD_CONTROLS':
                cam.controlSettings.enableKeys = param;
                break;
            case 'ORBIT_MIN_DISTANCE_PERSP':
                if (cam.isPerspectiveCamera) {
                    cam.controlSettings.orbitMinDistance = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MAX_DISTANCE_PERSP':
                if (cam.isPerspectiveCamera) {
                    cam.controlSettings.orbitMaxDistance = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MIN_ZOOM_ORTHO':
                if (cam.isOrthographicCamera) {
                    cam.controlSettings.orbitMinZoom = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MAX_ZOOM_ORTHO':
                if (cam.isOrthographicCamera) {
                    cam.controlSettings.orbitMaxZoom = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MIN_VERTICAL_ANGLE':
                cam.controlSettings.orbitMinPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_VERTICAL_ANGLE':
                cam.controlSettings.orbitMaxPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
                cam.controlSettings.orbitMinAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
                cam.controlSettings.orbitMaxAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_ALLOW_TURNOVER':
                cam.controlSettings.orbitEnableTurnover = param;
                break;
            case 'ENABLE_COLLISIONS':
                cam.controlSettings.enableCollisions = param;
                break;
            case 'CLIP_START':
                cam.near = param;
                cam.updateProjectionMatrix();
                break;
            case 'CLIP_END':
                cam.far = param;
                cam.updateProjectionMatrix();
                break;
        }

        if (isSetControlsParam)
            appInstance.enableControls();

    });
}

// Describe this function...
function set_scale(x) {
  setCameraParam('ORTHO_SCALE', 'camera', x);
}

// Describe this function...
function set_camera() {
  if (h * 2 > w) {
    setCameraParam('ORTHO_SCALE', 'camera', (h / w) * 2);
  } else {
    setCameraParam('ORTHO_SCALE', 'camera', 1);
  }
  set_x_offset((w / (h * 2)) * 0.25, 0.125);
  adaptive_scaling();
}

// show and hide puzzles
function changeVis(objSelector, bool) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        obj.visible = bool;
        obj.resolveMultiMaterial().forEach(function(objR) {
            objR.visible = bool;
        });
    }
}

// Describe this function...
function visibility_control(object, start, finish) {
  if (time > start && time < finish) {
    changeVis(object, true);
  } else {
    changeVis(object, false);
  }
}

// Describe this function...
function set_x_offset(t_x, t_y) {
  if (w > h) {
    x_offset = t_x;
    y_offset = 0;
  } else {
    x_offset = 0;
    y_offset = t_y;
  }
  setObjTransform('adaptive_center', false, 'position', [x_offset, y_offset, 0], false);
}

// Describe this function...
function PLAY(x, y) {
  transition = 1;
  dir = x;
  speed = y;
}

// Describe this function...
function scale_universe(s_u) {
  if (w > h * 2) {
    k = Math.max.apply(null, [s_u, 1, null]);
    setObjTransform('scale_universe', false, 'scale', [k, k, k], false);
  }
}

// Describe this function...
function adaptive_scaling() {
  if (w < h) {
    k_2 = w / (h * 2);
    setObjTransform('scale_logo', false, 'scale', [k_2, k_2, k_2], false);
    setObjTransform('arm_scale', false, 'scale', [k_2 * 1.6, k_2 * 1.6, k_2 * 1.6], false);
    setObjTransform('scale_data', false, 'scale', [k_2 * 1.6, k_2 * 1.6, k_2 * 1.6], false);
  } else {
    k_2 = 1;
    setObjTransform('scale_logo', false, 'scale', [k_2, k_2, k_2], false);
    setObjTransform('arm_scale', false, 'scale', [k_2, k_2, k_2], false);
    setObjTransform('scale_data', false, 'scale', [k_2, k_2, k_2], false);
    setObjTransform('scale_universe', false, 'scale', [k_2, k_2, k_2], false);
  }
}


registerEveryFrame(function() {
  setObjTransform('adaptive_center', false, 'rotation', [y_pos, x_pos, 0], false);
  setObjTransform('scale_logo', false, 'rotation', [y_pos, x_pos, 0], false);
  setObjTransform('earth pivot', false, 'rotation', [-90 - y_pos, x_pos, 0], false);
  if (transition == 1) {

    operateAnimation('SET_FRAME', crystals_on_earth, time, null, 'AUTO', 1,
            function() {}, false);


    operateAnimation('SET_FRAME', coins, time, null, 'AUTO', 1,
            function() {}, false);


    operateAnimation('SET_FRAME', transition_list, time, null, 'AUTO', 1,
            function() {}, false);

        time = time + dir * speed;
    if (time >= frames2[step + dir] && dir == 1) {
      transition = 0;
      step = step + dir;
    }
    if (time <= frames2[step + dir] && dir == -1) {
      transition = 0;
      step = step + dir;
    }
  }
  setMaterialValue('white_connections', 'anima', appInstance.clock.elapsedTime / 50);
  if (time > 409 && time < 481) {
    anti_adapt = (480 - time) / 70;
    scale_universe(anti_adapt * (w / (h * 2)));
    set_x_offset(anti_adapt * (w / (h * 2)) * 0.25, anti_adapt * 0.125);
  } else {
    if (time > 480) {
      set_x_offset(0, 0);
      scale_universe(1);
    } else {
      scale_universe(w / (h * 2));
      set_x_offset((w / (h * 2)) * 0.25, 0.125);
    }
  }
  visibility_control('mobile', 240, 320);
  visibility_control('morphing_screen', 300, 338);
  visibility_control('man', 310, 530);
  visibility_control('zoomed_universe', 310, 530);
  visibility_control('data_center', 140, 320);
  visibility_control('crystall.001', 140, 320);
  visibility_control('people_cube_1', 140, 320);
  visibility_control('people_cube_2', 140, 320);
  visibility_control('people_cube_3', 140, 320);
});

transition_list = ['offset_animation_universe', 'animate_universe_desktop', 'zoomed_universe', 'circle_bg_animation', 'dashboard', 'circle_frame', 'morphing_screen', 'new_universe', 'logo_center_222222', 'connections_new.001', 'data_center', 'data_center', 'Armature', 'Armature.001', 'Armature.002', 'cube_connect_1', 'cube_connect_2', 'cube_connect_3', 'arm', 'hand', 'mobile', 'main_circle with cubes', 'connections', '2_only_cube_1', '2_only_cube_2', '2_only_cube_3', '2_only_cube_4', '01_woman', 'human_02', 'human_03', 'man', 'circle_bg', 'earth pivot', 'crystal_timing_animation', 'animated_part_to_earth', 'white_connections'];

init();



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.disposeHTMLElements = function() {
    if (_pGlob) {
        _pGlob.htmlElements.forEach(elem => {
            elem.remove();
        });
        _pGlob.htmlElements.clear();
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    PL.disposeHTMLElements();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };
